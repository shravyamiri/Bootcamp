Day 0 – Setting Up My First Python Project
What I Accomplished
Created my first Python package named shravya-hello with a clean and modular structure

Used pyproject.toml for modern and standardized project configuration

Built a simple CLI application using Typer

Enhanced the CLI with rich formatting using the Rich library

Wrote detailed documentation including usage examples and badge integration

Set up a well-structured GitHub repository with a proper LICENSE, .gitignore, and a professional README

What I Learned
How to structure and configure Python packages using modern packaging tools

Building command-line applications with Typer

Making terminal output visually appealing using Rich

Writing effective and user-friendly README documentation

Managing dependencies and maintaining good project hygiene on GitHub

Day 1 – Diving into Documentation
What I Learned
Mastered the basics of Markdown for technical writing

Understood the importance of documentation in software development

Explored Mermaid syntax for diagrams and compared it with Draw.io, evaluating which is better suited for different use cases

Day 2-Language drills

First-Class Functions & Lambdas
Functions as values: You learned how to pass functions as arguments, return them, and store them in data structures.

Lambda functions: You used lambda for quick, anonymous functions, especially in map, filter, and sorting.

Closures: You understood how functions can capture and remember values from their enclosing scope.

Function composition: You wrote functions like compose(f, g) that combine other functions inline.

Decorator Skills
Basic decorators: You learned to wrap functions with additional behavior using @decorator syntax.

Decorator arguments: You wrote decorators that accept parameters, like log messages or role permissions.

Advanced patterns: You implemented retry logic, access control, and execution timing.

Decorator composition: You applied multiple decorators together and observed how execution order affects output.

Class method decorators: You validated arguments to class methods using decorators.

Using functools Efficiently
partial(): You learned to pre-fill function arguments to create new, simpler functions.

lru_cache: You used memoization to cache expensive recursive function results.

wraps(): You preserved original function metadata while writing decorators.

Reduce: You used reduce() to compute factorials by combining a sequence of values.

Default dictionaries: You used partial to customize dictionary creation behavior.

Mastering itertools
Infinite iterators: You used count(), cycle(), and repeat() to generate endless sequences or repeated patterns.

Efficient slicing: You used islice() to grab parts of iterables.

Duplicating iterators: You practiced with tee() to create multiple independent iterators.

Flattening & chaining: You used chain() to flatten nested iterables into one.

Grouping data: You grouped dictionaries using groupby().

Combinations & permutations: You generated all possible orderings and groupings of items in a list.


